(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{521:function(t,a,r){"use strict";r.r(a);var s=r(23),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"内存管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),r("h2",{attrs:{id:"内存生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存生命周期"}},[t._v("#")]),t._v(" 内存生命周期")]),t._v(" "),r("ol",[r("li",[t._v("分配你所需要的内存\n"),r("ul",[r("li",[t._v("JavaScript 在定义变量时就完成了内存分配")])])]),t._v(" "),r("li",[t._v("使用分配到的内存（读、写）")]),t._v(" "),r("li",[t._v("不需要时将其释放\\归还\n"),r("ul",[r("li",[t._v("高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。")])])])]),t._v(" "),r("h2",{attrs:{id:"垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),r("h3",{attrs:{id:"引用计数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),r("p",[t._v("最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。")]),t._v(" "),r("p",[t._v("限制：无法处理循环引用的事例。")]),t._v(" "),r("h3",{attrs:{id:"标记-清除算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法"}},[t._v("#")]),t._v(" 标记-清除算法")]),t._v(" "),r("p",[t._v("这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。")]),t._v(" "),r("p",[t._v("限制: 那些无法从根对象查询到的对象都将被清除。")])])}),[],!1,null,null,null);a.default=v.exports}}]);