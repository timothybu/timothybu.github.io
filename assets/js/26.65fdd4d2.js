(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{522:function(t,a,s){"use strict";s.r(a);var v=s(23),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),s("p",[t._v("简而言之，执行上下文就是当前 JavaScript 代码被解析和执行时所在"),s("strong",[t._v("环境")]),t._v("的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。")]),t._v(" "),s("h2",{attrs:{id:"类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),s("h3",{attrs:{id:"全局执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局执行上下文"}},[t._v("#")]),t._v(" 全局执行上下文")]),t._v(" "),s("p",[t._v("这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 "),s("code",[t._v("window")]),t._v(" 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。")]),t._v(" "),s("h3",{attrs:{id:"函数执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数执行上下文"}},[t._v("#")]),t._v(" 函数执行上下文")]),t._v(" "),s("p",[t._v("每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤。")]),t._v(" "),s("h3",{attrs:{id:"eval-执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eval-执行上下文"}},[t._v("#")]),t._v(" Eval 执行上下文")]),t._v(" "),s("p",[t._v("不常用")]),t._v(" "),s("h2",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),s("h3",{attrs:{id:"创建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建"}},[t._v("#")]),t._v(" 创建")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("创建变量对象")]),t._v("：首先初始化函数的参数 "),s("code",[t._v("arguments")]),t._v("，提升函数声明和变量声明。下文会详细说明。")]),t._v(" "),s("li",[s("strong",[t._v("创建作用域链")]),t._v("（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。(冒泡)")]),t._v(" "),s("li",[s("strong",[t._v("确定 "),s("code",[t._v("this")]),t._v(" 指向")]),t._v("：包括多种情况，下文会详细说明。")])]),t._v(" "),s("p",[t._v("在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。**变量先暂时赋值为 undefined，函数则先声明好可使用。**这一步做完了，然后再开始正式执行程序。")]),t._v(" "),s("p",[t._v("另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。")]),t._v(" "),s("h3",{attrs:{id:"执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行"}},[t._v("#")]),t._v(" 执行")]),t._v(" "),s("p",[t._v("执行变量赋值、代码执行")]),t._v(" "),s("h3",{attrs:{id:"回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回收"}},[t._v("#")]),t._v(" 回收")]),t._v(" "),s("p",[t._v("执行上下文出栈等待虚拟机回收执行上下文")]),t._v(" "),s("h2",{attrs:{id:"创建过程中的变量提升和-this-指向的细节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建过程中的变量提升和-this-指向的细节"}},[t._v("#")]),t._v(" 创建过程中的"),s("em",[t._v("变量提升")]),t._v("和* this 指向的细节*")])])}),[],!1,null,null,null);a.default=r.exports}}]);